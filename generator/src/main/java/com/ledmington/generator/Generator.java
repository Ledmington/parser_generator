/*
 * parser-gen - Parser Generator
 * Copyright (C) 2025-2025 Filippo Barbari <filippo.barbari@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.ledmington.generator;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import com.ledmington.ebnf.Expression;
import com.ledmington.ebnf.Grammar;
import com.ledmington.ebnf.Node;
import com.ledmington.ebnf.NonTerminal;
import com.ledmington.ebnf.OneOrMore;
import com.ledmington.ebnf.Or;
import com.ledmington.ebnf.Production;
import com.ledmington.ebnf.Sequence;
import com.ledmington.ebnf.Terminal;
import com.ledmington.ebnf.Utils;
import com.ledmington.ebnf.ZeroOrMore;
import com.ledmington.ebnf.ZeroOrOne;
import com.ledmington.generator.automata.AcceptingState;
import com.ledmington.generator.automata.AutomataUtils;
import com.ledmington.generator.automata.DFA;
import com.ledmington.generator.automata.NFA;
import com.ledmington.generator.automata.State;

/** Generates Java code to parse a specified EBNF grammar. */
@SuppressWarnings("PMD.AvoidDuplicateLiterals")
public final class Generator {

	private static final Map<Node, String> NODE_NAMES = new HashMap<>();

	private Generator() {}

	/**
	 * Generates a String containing Java source code to parse the given EBNF grammar.
	 *
	 * @param g The EBNF grammar to convert.
	 * @param parserName The name of the parser class produced.
	 * @param packageName The name of the package to output.
	 * @param indent The level of indentation to use when generating source code.
	 * @param generateMainMethod True to generate a self-contained executable parser which prints the resulting match.
	 * @return The indented Java source code of the parser of the given EBNF grammar.
	 */
	public static String generate(
			final Grammar g,
			final String parserName,
			final String packageName,
			final String indent,
			final boolean generateMainMethod) {
		NODE_NAMES.clear();

		final String startSymbol = GrammarChecker.check(g);

		final Map<Production, Integer> productions = g.productions();
		final Production startingProduction = productions.keySet().stream()
				.filter(x -> x.start().name().equals(startSymbol))
				.findFirst()
				.orElseThrow();
		if (Production.isLexerProduction(startingProduction.start().name())) {
			final Expression expr = startingProduction.result();
			productions.remove(startingProduction);
			final NonTerminal tmp = new NonTerminal("NEW_" + startSymbol);
			final NonTerminal newStart = new NonTerminal(startSymbol.toLowerCase(Locale.US));
			productions.put(new Production(newStart, tmp), 1);
			productions.put(new Production(tmp, expr), 1);
		}

		final List<Production> lexerProductions = new ArrayList<>();
		final List<Production> parserProductions;
		{
			// temporary list to hold parser productions
			final List<Production> tmp = new ArrayList<>();
			GrammarUtils.splitProductions(productions, lexerProductions, tmp);

			parserProductions = GrammarUtils.simplifyProductions(tmp);
		}

		// TODO: do we still need to generate names for nodes if all productions are simplified?
		generateNames(parserProductions);

		final Set<String> tokenNames =
				lexerProductions.stream().map(p -> p.start().name()).collect(Collectors.toUnmodifiableSet());

		final boolean atLeastOneSequence = parserProductions.stream().anyMatch(p -> p.result() instanceof Sequence);
		final boolean atLeastOneZeroOrOne = parserProductions.stream().anyMatch(p -> p.result() instanceof ZeroOrOne);
		final boolean atLeastOneZeroOrMore = parserProductions.stream().anyMatch(p -> p.result() instanceof ZeroOrMore);
		final boolean atLeastOneOneOrMore = parserProductions.stream().anyMatch(p -> p.result() instanceof OneOrMore);
		final boolean atLeastOneOr = parserProductions.stream().anyMatch(p -> p.result() instanceof Or);

		final IndentedStringBuilder sb = new IndentedStringBuilder(indent);
		sb.append("/*\n")
				.append(" * This file has been generated by the parser generator. Do not edit.\n")
				.append(" */\n");
		if (packageName != null && !packageName.isBlank()) {
			sb.append("package ").append(packageName).append(";\n\n");
		}
		if (generateMainMethod) {
			sb.append("import java.io.IOException;\n")
					.append("import java.nio.file.Files;\n")
					.append("import java.nio.file.Path;\n");
		}
		sb.append("import java.nio.ByteBuffer;\n")
				.append("import java.nio.ByteOrder;\n")
				.append("import java.util.ArrayList;\n")
				.append("import java.util.Arrays;\n")
				.append("import java.util.Base64;\n")
				.append("import java.util.List;\n");
		sb.append("import java.util.Objects;\n");
		if (atLeastOneSequence) {
			sb.append("import java.util.Stack;\n");
		}
		if (atLeastOneSequence || atLeastOneZeroOrMore || generateMainMethod) {
			sb.append('\n');
		}
		sb.append("public final class ")
				.append(parserName)
				.append(" {\n")
				.indent()
				.append("private Token[] v = null;\n")
				.append("private int pos = 0;\n");
		if (atLeastOneSequence) {
			sb.append("private final Stack<Integer> stack = new Stack<>();\n");
		}
		sb.append("public interface Node {\n")
				.indent()
				.append("String name();\n")
				.deindent()
				.append("}\n")
				.append("public record Terminal(String literal) implements Node {\n")
				.indent()
				.append("@Override\n")
				.append("public String name() {\n")
				.indent()
				.append("return \"Terminal\";\n")
				.deindent()
				.append("}\n")
				.deindent()
				.append("}\n")
				.append("public interface NonTerminal extends Node {\n")
				.indent()
				.append("Node match();\n")
				.deindent()
				.append("}\n");
		if (atLeastOneZeroOrOne) {
			sb.append("public interface ZeroOrOne extends Node {\n")
					.indent()
					.append("Node match();\n")
					.deindent()
					.append("}\n");
		}
		if (atLeastOneSequence) {
			sb.append("public interface Sequence extends Node {\n")
					.indent()
					.append("List<Node> nodes();\n")
					.deindent()
					.append("}\n");
		}
		if (atLeastOneZeroOrMore) {
			sb.append("public interface ZeroOrMore extends Node {\n")
					.indent()
					.append("List<Node> nodes();\n")
					.deindent()
					.append("}\n");
		}
		if (atLeastOneOneOrMore) {
			sb.append("public interface OneOrMore extends Node {\n")
					.indent()
					.append("List<Node> nodes();\n")
					.deindent()
					.append("}\n");
		}
		if (atLeastOneOr) {
			sb.append("public interface Or extends Node {\n")
					.indent()
					.append("Node match();\n")
					.deindent()
					.append("}\n");
		}

		for (final Production p : parserProductions) {
			final String newNodeName = p.start().name();
			switch (p.result()) {
				case NonTerminal nt ->
					sb.append("public record ")
							.append(newNodeName)
							.append('(')
							.append(getGenerateNodeTypeName(nt, tokenNames))
							.append(' ')
							.append(nt.name())
							.append(") implements NonTerminal {\n")
							.indent()
							.append("@Override\n")
							.append("public String name() {\n")
							.indent()
							.append("return \"" + newNodeName + "\";\n")
							.deindent()
							.append("}\n")
							.append("@Override\n")
							.append("public Node match() {\n")
							.indent()
							.append("return " + nt.name() + ";\n")
							.deindent()
							.append("}\n")
							.deindent()
							.append("}\n");
				case Sequence(final List<Expression> nodes) -> {
					final Map<String, Integer> nameCounter = new HashMap<>();
					final List<String> nodeNames = new ArrayList<>();
					for (final Expression exp : nodes) {
						final String typeName = getGenerateNodeTypeName(exp, tokenNames);
						final String nodeName = NODE_NAMES.get(exp);
						if (!nameCounter.containsKey(typeName)) {
							nameCounter.put(typeName, 0);
							nodeNames.add(nodeName + "_0");
						} else {
							nameCounter.put(typeName, nameCounter.get(typeName) + 1);
							final String name = nodeName + "_" + nameCounter.get(typeName);
							nodeNames.add(name);
						}
					}
					sb.append("public record ")
							.append(newNodeName)
							.append('(')
							.append(IntStream.range(0, nodes.size())
									.mapToObj(i ->
											getGenerateNodeTypeName(nodes.get(i), tokenNames) + " " + nodeNames.get(i))
									.collect(Collectors.joining(", ")))
							.append(") implements Sequence {\n")
							.indent()
							.append("@Override\n")
							.append("public String name() {\n")
							.indent()
							.append("return \"")
							.append(newNodeName)
							.append("\";\n")
							.deindent()
							.append("}\n")
							.append("@Override\n")
							.append("public List<Node> nodes() {\n")
							.indent()
							.append("return List.of(")
							.append(IntStream.range(0, nodes.size())
									.mapToObj(nodeNames::get)
									.collect(Collectors.joining(", ")))
							.append(");\n")
							.deindent()
							.append("}\n")
							.deindent()
							.append("}\n");
				}
				case Or ignored ->
					sb.append("public record ")
							.append(newNodeName)
							.append("(Node match) implements Or {\n")
							.indent()
							.append("@Override\n")
							.append("public String name() {\n")
							.indent()
							.append("return \"")
							.append(newNodeName)
							.append("\";\n")
							.deindent()
							.append("}\n")
							.deindent()
							.append("}\n");
				case ZeroOrOne(final Expression inner) ->
					sb.append("public record ")
							.append(newNodeName)
							.append("(" + getGenerateNodeTypeName(inner, tokenNames) + " " + NODE_NAMES.get(inner)
									+ ") implements ZeroOrOne {\n")
							.indent()
							.append("@Override\n")
							.append("public String name() {\n")
							.indent()
							.append("return \"")
							.append(newNodeName)
							.append("\";\n")
							.deindent()
							.append("}\n")
							.append("@Override\n")
							.append("public Node match() {\n")
							.indent()
							.append("return " + NODE_NAMES.get(inner) + ";\n")
							.deindent()
							.append("}\n")
							.deindent()
							.append("}\n");
				case ZeroOrMore(final Expression inner) ->
					sb.append("public record ")
							.append(newNodeName)
							.append("(List<")
							.append(getGenerateNodeTypeName(inner, tokenNames))
							.append("> ")
							.append(NODE_NAMES.get(inner))
							.append(") implements ZeroOrMore {\n")
							.indent()
							.append("@Override\n")
							.append("public String name() {\n")
							.indent()
							.append("return \"")
							.append(newNodeName)
							.append("\";\n")
							.deindent()
							.append("}\n")
							.append("@Override\n")
							.append("public List<Node> nodes() {\n")
							.indent()
							.append("return ")
							.append(NODE_NAMES.get(inner))
							.append(".stream().map(n -> (Node) n).toList();\n")
							.deindent()
							.append("}\n")
							.deindent()
							.append("}\n");
				case OneOrMore(final Expression inner) ->
					sb.append("public record ")
							.append(newNodeName)
							.append("(List<")
							.append(getGenerateNodeTypeName(inner, tokenNames))
							.append("> ")
							.append(NODE_NAMES.get(inner))
							.append(") implements OneOrMore {\n")
							.indent()
							.append("@Override\n")
							.append("public String name() {\n")
							.indent()
							.append("return \"")
							.append(newNodeName)
							.append("\";\n")
							.deindent()
							.append("}\n")
							.append("@Override\n")
							.append("public List<Node> nodes() {\n")
							.indent()
							.append("return ")
							.append(NODE_NAMES.get(inner))
							.append(".stream().map(n -> (Node) n).toList();\n")
							.deindent()
							.append("}\n")
							.deindent()
							.append("}\n");
				default -> throw new IllegalArgumentException(String.format("Unknown node: '%s'.", p.result()));
			}
		}

		final String lexerName = parserName + "_Lexer";

		generateLexer(sb, lexerName, lexerProductions);

		sb.append("public Node parse(final String input) {\n").indent().append("final Node result;\n");

		sb.append("final ")
				.append(lexerName)
				.append(" lexer = new ")
				.append(lexerName)
				.append("();\n")
				.append("try {\n")
				.indent()
				.append("this.v = lexer.tokenize(input).toArray(new Token[0]);\n")
				.deindent()
				.append("} catch (final IllegalArgumentException e) {\n")
				.indent()
				.append("return null;\n")
				.deindent()
				.append("}\n")
				.append("this.pos = 0;\n")
				.append("try {\n")
				.indent();

		if (lexerProductions.stream().anyMatch(p -> p.start().name().equals(startSymbol))) {
			sb.append("result = parseTerminal(TokenType." + startSymbol + ");\n");
		} else {
			sb.append("result = parse_" + startSymbol + "();\n");
		}

		sb.deindent()
				.append("} catch (final ArrayIndexOutOfBoundsException e) {\n")
				.indent()
				.append("return null;\n")
				.deindent()
				.append("}\n");
		if (atLeastOneSequence) {
			sb.append("return (pos == v.length && stack.isEmpty()) ? result : null;\n");
		} else {
			sb.append("return pos == v.length ? result : null;\n");
		}
		sb.deindent().append("}\n");

		for (final Production p : parserProductions) {
			final NonTerminal start = p.start();
			final Expression result = p.result();
			final String productionName = start.name();

			switch (result) {
				case NonTerminal nt -> generateNonTerminal(sb, start, nt, tokenNames);
				case Sequence s -> generateSequence(sb, productionName, s, tokenNames);
				case Or or -> generateOr(sb, productionName, or, tokenNames);
				case ZeroOrOne zoo -> generateZeroOrOne(sb, productionName, zoo, tokenNames);
				case ZeroOrMore zom -> generateZeroOrMore(sb, productionName, zom, tokenNames);
				case OneOrMore oom -> generateOneOrMore(sb, productionName, oom, tokenNames);
				default -> throw new IllegalArgumentException(String.format("Unknown node: '%s'", result));
			}
		}

		sb.append("private Terminal parseTerminal(final TokenType expected) {\n")
				.indent()
				.append("if (pos < v.length && v[pos].type() == expected) {\n")
				.indent()
				.append("return new Terminal(v[pos++].content());\n")
				.deindent()
				.append("}\n")
				.append("return null;\n")
				.deindent()
				.append("}\n");

		if (generateMainMethod) {
			sb.append(
							"private static void printNode(final Node n, final String indent, final String continuationIndent) {\n")
					.indent()
					.append("final char verticalLine = '│';\n")
					.append("final char horizontalLine = '─';\n")
					.append("final char joint = '├';\n")
					.append("final char angle = '└';\n")
					.append("switch (n) {\n")
					.indent()
					.append("case Terminal t -> System.out.println(indent + \"Terminal '\" + t.literal() + \"'\");\n")
					.append("case NonTerminal nt -> {\n")
					.indent()
					.append("System.out.println(indent + nt.name());\n")
					.append(
							"printNode(nt.match(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
					.deindent()
					.append("}\n");
			if (atLeastOneOr) {
				sb.append("case Or or -> {\n")
						.indent()
						.append("System.out.println(indent + or.name());\n")
						.append(
								"printNode(or.match(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			if (atLeastOneSequence) {
				sb.append("case Sequence s -> {\n")
						.indent()
						.append("System.out.println(indent + s.name());\n")
						.append("final List<Node> children = s.nodes();\n")
						.append("final int len = children.size();\n")
						.append("for (int i = 0; i < len - 1; i++) {\n")
						.indent()
						.append(
								"printNode(children.get(i), continuationIndent + \" \" + joint + horizontalLine, continuationIndent + ' ' + verticalLine + ' ');\n")
						.deindent()
						.append("}\n")
						.append(
								"printNode(children.getLast(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			if (atLeastOneZeroOrMore) {
				sb.append("case ZeroOrMore zom -> {\n")
						.indent()
						.append("System.out.println(indent + \"ZeroOrMore\");\n")
						.append("final List<Node> children = zom.nodes();\n")
						.append("final int len = children.size();\n")
						.append("for (int i = 0; i < len - 1; i++) {\n")
						.indent()
						.append(
								"printNode(children.get(i), continuationIndent + \" \" + joint + horizontalLine, continuationIndent + ' ' + verticalLine + ' ');\n")
						.deindent()
						.append("}\n")
						.append(
								"printNode(len == 0 ? null : children.getLast(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			if (atLeastOneOneOrMore) {
				sb.append("case OneOrMore oom -> {\n")
						.indent()
						.append("System.out.println(indent + \"OneOrMore\");\n")
						.append("final List<Node> children = oom.nodes();\n")
						.append("final int len = children.size();\n")
						.append("for (int i = 0; i < len - 1; i++) {\n")
						.indent()
						.append(
								"printNode(children.get(i), continuationIndent + \" \" + joint + horizontalLine, continuationIndent + ' ' + verticalLine + ' ');\n")
						.deindent()
						.append("}\n")
						.append(
								"printNode(children.getLast(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			if (atLeastOneZeroOrOne) {
				sb.append("case ZeroOrOne zoo -> {\n")
						.indent()
						.append("System.out.println(indent + \"ZeroOrOne\");\n")
						.append(
								"printNode(zoo.match(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			sb.append("case null -> System.out.println(indent + \"null\");\n")
					.append(
							"default -> throw new IllegalArgumentException(String.format(\"Unknown node: '%s'.\", n));\n")
					.deindent()
					.append("}\n")
					.deindent()
					.append("}\n")
					.append("public static void main(final String[] args) {\n")
					.indent()
					.append("if (args.length != 1) {\n")
					.indent()
					.append("throw new RuntimeException(\"Expected the file to read input from.\");\n")
					.deindent()
					.append("}\n")
					.append("final ")
					.append(parserName)
					.append(" parser = new ")
					.append(parserName)
					.append("();\n")
					.append("final Node result;\n")
					.append("try {\n")
					.indent()
					.append("result = parser.parse(Files.readString(Path.of(args[0])));\n")
					.deindent()
					.append("} catch (final IOException e) {\n")
					.indent()
					.append("throw new RuntimeException(e);\n")
					.deindent()
					.append("}\n")
					.append("printNode(result, \"\", \"\");\n")
					.deindent()
					.append("}\n");
		}

		return sb.deindent().append("}").toString();
	}

	// TODO: change name of this method
	private static String getGenerateNodeTypeName(final Expression n, final Set<String> tokenNames) {
		return switch (n) {
			case NonTerminal nt -> tokenNames.contains(nt.name()) ? "Terminal" : nt.name();
			case Sequence ignored -> "Sequence";
			case ZeroOrMore ignored -> "ZeroOrMore";
			case ZeroOrOne ignored -> "ZeroOrOne";
			default -> throw new IllegalArgumentException(String.format("Unknown node: '%s'.", n));
		};
	}

	private static void generateLexer(
			final IndentedStringBuilder sb, final String lexerName, final List<Production> lexerProductions) {
		final NFA epsilonNFA = AutomataUtils.grammarToEpsilonNFA(lexerProductions);
		AutomataUtils.assertEpsilonNFAValid(epsilonNFA);
		final NFA nfa = AutomataUtils.epsilonNFAtoNFA(epsilonNFA);
		AutomataUtils.assertNFAValid(nfa);
		final DFA dfa = AutomataUtils.NFAtoDFA(nfa);
		AutomataUtils.assertDFAValid(dfa);
		final DFA minimizedDFA = AutomataUtils.minimizeDFA(dfa);
		AutomataUtils.assertDFAValid(minimizedDFA);

		// re-index DFA states
		final Map<State, Integer> stateIndex = new HashMap<>();
		{
			stateIndex.put(minimizedDFA.startingState(), 0);
			int idx = 1;
			for (final State s : minimizedDFA.states()) {
				if (s.equals(minimizedDFA.startingState())) {
					continue;
				}
				stateIndex.put(s, idx);
				idx++;
			}
		}

		final List<State> allStates = stateIndex.entrySet().stream()
				.sorted(Entry.comparingByValue())
				.map(Entry::getKey)
				.toList();

		sb.append("public enum TokenType {\n")
				.indent()
				.append(lexerProductions.stream()
						.map(p -> p.start().name())
						.sorted()
						.collect(Collectors.joining(",\n")))
				.append('\n')
				.deindent()
				.append("}\n");
		sb.append("public record Token(TokenType type, String content) {\n")
				.indent()
				.append("public Token {\n")
				.indent()
				.append("Objects.requireNonNull(type);\n")
				.append("Objects.requireNonNull(content);\n")
				.deindent()
				.append("}\n")
				.deindent()
				.append("}\n");

		sb.append("public static final class ").append(lexerName).append(" {\n").indent();

		final int maxPerRow = 10;
		sb.append("private final boolean[] isAccepting = new boolean[] {\n").indent();
		for (int i = 0; i < allStates.size(); i++) {
			final State s = allStates.get(i);
			sb.append(s.isAccepting() ? "true" : "false");
			if (i < allStates.size() - 1) {
				sb.append(',');
				if (i % maxPerRow == maxPerRow - 1) {
					sb.append('\n');
				} else {
					sb.append(' ');
				}
			}
		}
		sb.deindent().append("\n};\n");
		sb.append("private final boolean[] isSkippable = new boolean[] {\n").indent();
		for (int i = 0; i < allStates.size(); i++) {
			final State s = allStates.get(i);
			sb.append((s.isAccepting() && Production.isSkippable(((AcceptingState) s).tokenName())) ? "true" : "false");
			if (i < allStates.size() - 1) {
				sb.append(',');
				if (i % maxPerRow == maxPerRow - 1) {
					sb.append('\n');
				} else {
					sb.append(' ');
				}
			}
		}
		sb.deindent().append("\n};\n");

		sb.append("private final List<TokenType> tokensToMatch = Arrays.asList(\n")
				.indent();
		for (int i = 0; i < allStates.size(); i++) {
			final State s = allStates.get(i);
			sb.append(s.isAccepting() ? "TokenType." + ((AcceptingState) s).tokenName() : "null");
			if (i < allStates.size() - 1) {
				sb.append(',');
			}
			sb.append('\n');
		}
		sb.deindent().append(");\n");

		final int allTransitions = minimizedDFA.states().stream()
				.mapToInt(s -> minimizedDFA.neighbors(s).size())
				.sum();
		final int[] offsets = new int[allStates.size() + 1];
		offsets[0] = 0;
		final char[] symbols = new char[allTransitions];
		final int[] destinations = new int[allTransitions];
		int idx = 0;
		for (int i = 1; i < allStates.size() + 1; i++) {
			final State s = allStates.get(i - 1);
			offsets[i] = offsets[i - 1] + minimizedDFA.neighbors(s).size();
			for (final Entry<Character, State> e : minimizedDFA.neighbors(s).entrySet().stream()
					.sorted(Entry.comparingByKey())
					.toList()) {
				symbols[idx] = e.getKey();
				destinations[idx] = stateIndex.get(e.getValue());
				idx++;
			}
		}
		sb.append("private final int[] offsets;\n")
				.append("private final char[] symbols;\n")
				.append("private final int[] destinations;\n");

		final int totalBytes = 4
				+ 4
				+ Integer.BYTES * offsets.length
				+ Character.BYTES * symbols.length
				+ Integer.BYTES * destinations.length;
		final ByteBuffer bb = ByteBuffer.allocate(totalBytes).order(ByteOrder.BIG_ENDIAN);

		bb.putInt(offsets.length);
		bb.putInt(symbols.length);
		for (final int off : offsets) {
			bb.putInt(off);
		}
		for (final char sym : symbols) {
			bb.putChar(sym);
		}
		for (final int dest : destinations) {
			bb.putInt(dest);
		}

		final String encoded = Base64.getEncoder().encodeToString(bb.array());

		sb.append("public ")
				.append(lexerName)
				.append("() {\n")
				.indent()
				.append("final String encoded = \"")
				.append(Utils.getEscapedString(encoded))
				.append("\";\n")
				.append(
						"final ByteBuffer bb = ByteBuffer.wrap(Base64.getDecoder().decode(encoded)).order(ByteOrder.BIG_ENDIAN);\n")
				.append("final int num_offsets = bb.getInt();\n")
				.append("final int num_destinations = bb.getInt();\n")
				.append("this.offsets = new int[num_offsets];\n")
				.append("this.symbols = new char[num_destinations];\n")
				.append("this.destinations = new int[num_destinations];\n")
				.append("for (int i = 0; i < num_offsets; i++) {\n")
				.indent()
				.append("this.offsets[i] = bb.getInt();\n")
				.deindent()
				.append("}\n")
				.append("for (int i = 0; i < num_destinations; i++) {\n")
				.indent()
				.append("this.symbols[i] = bb.getChar();\n")
				.deindent()
				.append("}\n")
				.append("for (int i = 0; i < num_destinations; i++) {\n")
				.indent()
				.append("this.destinations[i] = bb.getInt();\n")
				.deindent()
				.append("}\n")
				.deindent()
				.append("}\n")
				// TODO: this can optimized to a binary search
				.append("private int transition(final int currentState, final char symbol) {\n")
				.indent()
				.append("final int start = this.offsets[currentState];\n")
				.append("final int end = this.offsets[currentState + 1];\n")
				.append("for (int i = start; i < end; i++) {\n")
				.indent()
				.append("if (this.symbols[i] == symbol) {\n")
				.indent()
				.append("return this.destinations[i];\n")
				.deindent()
				.append("}\n")
				.deindent()
				.append("}\n")
				.append("return -1;\n")
				.deindent()
				.append("}\n")
				.append("public List<Token> tokenize(final String input) {\n")
				.indent()
				.append("final char[] v = input.toCharArray();\n")
				.append("int pos = 0;\n")
				.append("int lastTokenMatchStart = 0;\n")
				.append("int lastTokenMatchEnd = 0;\n")
				.append("final List<Token> tokens = new ArrayList<>();\n")
				.append("int currentState = 0;\n")
				.append("while (pos < v.length) {\n")
				.indent()
				.append("if (isAccepting[currentState]) {\n")
				.indent()
				.append("lastTokenMatchEnd = pos;\n")
				.deindent()
				.append("}\n")
				.append("final char ch = v[pos];\n")
				.append("final int nextState = transition(currentState, ch);\n")
				.append("if (nextState != -1) {\n")
				.indent()
				.append("currentState = nextState;\n")
				.append("pos++;\n")
				.deindent()
				.append("} else {\n")
				.indent()
				.append("if (isAccepting[currentState]) {\n")
				.indent()
				.append("final int length = lastTokenMatchEnd - lastTokenMatchStart;\n")
				.append("if (length == 0) {\n")
				.indent()
				.append(
						"throw new IllegalArgumentException(String.format(\"No token emitted for empty match at index %,d.\", pos));\n")
				.deindent()
				.append("}\n")
				.append("if (!isSkippable[currentState]) {\n")
				.indent()
				.append("final String match = String.copyValueOf(v, lastTokenMatchStart, length);\n")
				.append("tokens.add(new Token(tokensToMatch.get(currentState), match));\n")
				.deindent()
				.append("}\n")
				.append("lastTokenMatchStart = pos;\n")
				.append("lastTokenMatchEnd = -1;\n")
				.append("currentState = 0;\n")
				.deindent()
				.append("} else {\n")
				.indent()
				.append("throw new IllegalArgumentException(String.format(\"Lexical error at index %,d.\", pos));\n")
				.deindent()
				.append("}\n")
				.deindent()
				.append("}\n")
				.deindent()
				.append("}\n")
				.append("if (isAccepting[currentState]) {\n")
				.indent()
				.append("lastTokenMatchEnd = pos;\n")
				.deindent()
				.append("}\n")
				.append("final int length = lastTokenMatchEnd - lastTokenMatchStart;\n")
				.append("if (isAccepting[currentState] && length > 0 && !isSkippable[currentState]) {\n")
				.indent()
				.append("final String match = String.copyValueOf(v, lastTokenMatchStart, length);\n")
				.append("tokens.add(new Token(tokensToMatch.get(currentState), match));\n")
				.deindent()
				.append("}\n")
				.append("return tokens;\n")
				.deindent()
				.append("}\n")
				.deindent()
				.append("}\n");
	}

	private static void generateOr(
			final IndentedStringBuilder sb, final String productionName, final Or or, final Set<String> tokenNames) {
		sb.append("private " + productionName + " parse_" + productionName + "() {\n")
				.indent();
		final List<Expression> nodes = or.nodes();
		for (int i = 0; i < nodes.size(); i++) {
			final Expression exp = nodes.get(i);
			final String nodeName = "n_" + i;
			final String actualName = NODE_NAMES.get(exp);
			final String innerTypeName = getGenerateNodeTypeName(exp, tokenNames);
			sb.append("final " + innerTypeName + " " + nodeName + " = ");
			if (exp instanceof NonTerminal && tokenNames.contains(actualName)) {
				sb.append("parseTerminal(TokenType." + actualName + ");\n");
			} else {
				sb.append("parse_" + actualName + "();\n");
			}
			sb.append("if (" + nodeName + " != null) {\n")
					.indent()
					.append("return new ")
					.append(productionName)
					.append("(" + nodeName + ");\n")
					.deindent()
					.append("}\n");
		}
		sb.append("return null;\n").deindent().append("}\n");
	}

	private static void generateZeroOrMore(
			final IndentedStringBuilder sb,
			final String productionName,
			final ZeroOrMore zom,
			final Set<String> tokenNames) {
		final String actualName = NODE_NAMES.get(zom.inner());
		final String innerTypeName = getGenerateNodeTypeName(zom.inner(), tokenNames);
		sb.append("private " + productionName + " parse_" + productionName + "() {\n")
				.indent()
				.append("final List<" + innerTypeName + "> nodes = new ArrayList<>();\n")
				.append("while (true) {\n")
				.indent()
				.append("final " + innerTypeName + " n = ");
		if (zom.inner() instanceof NonTerminal && tokenNames.contains(actualName)) {
			sb.append("parseTerminal(TokenType." + actualName + ")");
		} else {
			sb.append("parse_" + actualName + "()");
		}
		sb.append(";\n");
		if (!(zom.inner() instanceof ZeroOrMore) && !(zom.inner() instanceof ZeroOrOne)) {
			sb.append("if (n == null) {\n")
					.indent()
					.append("break;\n")
					.deindent()
					.append("}\n");
		}
		sb.append("nodes.add(n);\n")
				.deindent()
				.append("}\n")
				.append("return new ")
				.append(productionName)
				.append("(nodes);\n")
				.deindent()
				.append("}\n");
	}

	private static void generateOneOrMore(
			final IndentedStringBuilder sb,
			final String productionName,
			final OneOrMore oom,
			final Set<String> tokenNames) {
		final String actualName = NODE_NAMES.get(oom.inner());
		final String innerTypeName = getGenerateNodeTypeName(oom.inner(), tokenNames);
		sb.append("private " + productionName + " parse_" + productionName + "() {\n")
				.indent()
				.append("final List<" + innerTypeName + "> nodes = new ArrayList<>();\n");
		sb.append("final " + innerTypeName + " n_0 = ");
		if (oom.inner() instanceof NonTerminal && tokenNames.contains(actualName)) {
			sb.append("parseTerminal(TokenType." + actualName + ")");
		} else {
			sb.append("parse_" + actualName + "()");
		}
		sb.append(";\n").append("nodes.add(n_0);\n");
		if (!(oom.inner() instanceof ZeroOrMore) && !(oom.inner() instanceof ZeroOrOne)) {
			sb.append("if (n_0 == null) {\n")
					.indent()
					.append("return null;\n")
					.deindent()
					.append("}\n");
		}
		sb.append("while (true) {\n").indent();
		sb.append("final " + innerTypeName + " n = ");
		if (oom.inner() instanceof NonTerminal && tokenNames.contains(actualName)) {
			sb.append("parseTerminal(TokenType." + actualName + ")");
		} else {
			sb.append("parse_" + actualName + "()");
		}
		sb.append(";\n");
		if (!(oom.inner() instanceof ZeroOrMore) && !(oom.inner() instanceof ZeroOrOne)) {
			sb.append("if (n == null) {\n")
					.indent()
					.append("break;\n")
					.deindent()
					.append("}\n");
		}
		sb.append("nodes.add(n);\n")
				.deindent()
				.append("}\n")
				.append("return new " + productionName + "(nodes);\n")
				.deindent()
				.append("}\n");
	}

	private static void generateSequence(
			final IndentedStringBuilder sb,
			final String productionName,
			final Sequence s,
			final Set<String> tokenNames) {
		sb.append("private " + productionName + " parse_" + productionName + "() {\n")
				.indent()
				.append("stack.push(this.pos);\n");

		final List<Expression> seq = s.nodes();
		for (int i = 0; i < seq.size(); i++) {
			final Expression exp = seq.get(i);
			final String nodeName = "n_" + i;
			final String actualName = NODE_NAMES.get(exp);
			final String innerTypeName = getGenerateNodeTypeName(exp, tokenNames);
			sb.append("final " + innerTypeName + " " + nodeName + " = ");
			if (exp instanceof NonTerminal && tokenNames.contains(actualName)) {
				sb.append("parseTerminal(TokenType." + actualName + ")");
			} else {
				sb.append("parse_" + actualName + "()");
			}
			sb.append(";\n");
			if (!(exp instanceof ZeroOrMore) && !(exp instanceof ZeroOrOne)) {
				sb.append("if (" + nodeName + " == null) {\n")
						.indent()
						.append("this.pos = stack.pop();\n")
						.append("return null;\n")
						.deindent()
						.append("}\n");
			}
		}

		sb.append("stack.pop();\n")
				.append("return new " + productionName + "(")
				.append(IntStream.range(0, seq.size()).mapToObj(i -> "n_" + i).collect(Collectors.joining(", ")))
				.append(");\n")
				.deindent()
				.append("}\n");
	}

	private static void generateNonTerminal(
			final IndentedStringBuilder sb,
			final NonTerminal start,
			final Expression result,
			final Set<String> tokenNames) {
		final String typeName = NODE_NAMES.get(start);
		final String innerTypeName = getGenerateNodeTypeName(result, tokenNames);
		sb.append("private " + typeName + " parse_" + typeName)
				.append("() {\n")
				.indent()
				.append("final " + innerTypeName + " inner = ");
		if (result instanceof NonTerminal(final String tokenName) && tokenNames.contains(tokenName)) {
			sb.append("parseTerminal(TokenType." + tokenName + ")");
		} else {
			sb.append("parse_" + NODE_NAMES.get(result) + "()");
		}
		sb.append(";\n");

		if (result instanceof ZeroOrOne) {
			sb.append("return new " + typeName + "(inner);\n");
		} else {
			sb.append("return inner == null ? null : new " + typeName + "(inner);\n");
		}
		sb.deindent().append("}\n");
	}

	private static void generateNames(final List<Production> parserProductions) {
		final Set<Node> visited = new HashSet<>();
		final Queue<Node> q = new ArrayDeque<>();

		for (final Production p : parserProductions) {
			q.add(p.start());
			q.add(p.result());
			NODE_NAMES.put(p.result(), p.start().name());
		}

		int zeroOrOneCounter = 0;
		int sequenceCounter = 0;
		int zeroOrMoreCounter = 0;
		int oneOrMoreCounter = 0;
		int orCounter = 0;
		while (!q.isEmpty()) {
			final Node n = q.remove();
			if (visited.contains(n)) {
				continue;
			}
			visited.add(n);
			switch (n) {
				case Terminal ignored -> {}
				case NonTerminal nt -> NODE_NAMES.put(nt, nt.name());
				case ZeroOrOne zoo -> {
					NODE_NAMES.put(zoo, "zero_or_one_" + zeroOrOneCounter);
					q.add(zoo.inner());
					zeroOrOneCounter++;
				}
				case ZeroOrMore zom -> {
					NODE_NAMES.put(zom, "zero_or_more_" + zeroOrMoreCounter);
					zeroOrMoreCounter++;
					q.add(zom.inner());
				}
				case OneOrMore oom -> {
					NODE_NAMES.put(oom, "one_or_more_" + oneOrMoreCounter);
					oneOrMoreCounter++;
					q.add(oom.inner());
				}
				case Sequence s -> {
					if (!NODE_NAMES.containsKey(s)) {
						NODE_NAMES.put(s, "sequence_" + sequenceCounter);
						sequenceCounter++;
					}
					q.addAll(s.nodes());
				}
				case Or or -> {
					NODE_NAMES.put(or, "or_" + orCounter);
					orCounter++;
					q.addAll(or.nodes());
				}
				default -> throw new IllegalArgumentException(String.format("Unknown Node '%s'.", n));
			}
		}
	}

	private static void generateZeroOrOne(
			final IndentedStringBuilder sb,
			final String productionName,
			final ZeroOrOne o,
			final Set<String> tokenNames) {
		final String innerName = NODE_NAMES.get(o.inner());
		final String innerTypeName = getGenerateNodeTypeName(o.inner(), tokenNames);
		sb.append("private " + productionName + " parse_" + productionName + "() {\n")
				.indent()
				.append("final " + innerTypeName + " inner = ");
		if (o.inner() instanceof NonTerminal && tokenNames.contains(innerName)) {
			sb.append("parseTerminal(TokenType." + innerName + ")");
		} else {
			sb.append("parse_" + innerName + "()");
		}
		sb.append(";\n")
				.append("return new ")
				.append(productionName)
				.append("(inner);\n")
				.deindent()
				.append("}\n");
	}
}
