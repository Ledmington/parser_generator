/*
 * parser-gen - Parser Generator
 * Copyright (C) 2025-2025 Filippo Barbari <filippo.barbari@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.ledmington.generator;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import com.ledmington.ebnf.Grammar;
import com.ledmington.ebnf.Node;
import com.ledmington.ebnf.NonTerminal;
import com.ledmington.ebnf.OneOrMore;
import com.ledmington.ebnf.Or;
import com.ledmington.ebnf.Production;
import com.ledmington.ebnf.Sequence;
import com.ledmington.ebnf.Terminal;
import com.ledmington.ebnf.ZeroOrMore;
import com.ledmington.ebnf.ZeroOrOne;

/** Generates Java code to parse a specified EBNF grammar. */
@SuppressWarnings("PMD.AvoidDuplicateLiterals")
public final class Generator {

	private static final Map<Node, String> NODE_NAMES = new HashMap<>();

	private Generator() {}

	/**
	 * Generates a String containing Java source code to parse the given EBNF grammar.
	 *
	 * @param g The EBNF grammar to convert.
	 * @param parserName The name of the parser class produced.
	 * @param packageName The name of the package to output.
	 * @param indent The level of indentation to use when generating source code.
	 * @param generateMainMethod True to generate a self-contained executable parser which prints the resulting match.
	 * @return The indented Java source code of the parser of the given EBNF grammar.
	 */
	@SuppressWarnings("PMD.AvoidLiteralsInIfCondition")
	public static String generate(
			final Grammar g,
			final String parserName,
			final String packageName,
			final String indent,
			final boolean generateMainMethod) {
		NODE_NAMES.clear();

		final String startSymbol = GrammarChecker.check(g);

		final Map<Production, Integer> productions = g.productions();

		final List<Production> lexerProductions = new ArrayList<>();
		final List<Production> parserProductions;
		{
			// temporary list to hold parser productions
			final List<Production> tmp = new ArrayList<>();
			GrammarUtils.splitProductions(productions, lexerProductions, tmp);

			parserProductions = GrammarUtils.simplifyProductions(tmp);
		}

		generateNames(parserProductions);

		final Set<String> tokenNames =
				lexerProductions.stream().map(p -> p.start().name()).collect(Collectors.toUnmodifiableSet());

		final boolean atLeastOneSequence = parserProductions.stream().anyMatch(p -> p.result() instanceof Sequence);
		final boolean atLeastOneZeroOrOne = parserProductions.stream().anyMatch(p -> p.result() instanceof ZeroOrOne);
		final boolean atLeastOneZeroOrMore = parserProductions.stream().anyMatch(p -> p.result() instanceof ZeroOrMore);
		final boolean atLeastOneOneOrMore = parserProductions.stream().anyMatch(p -> p.result() instanceof OneOrMore);
		final boolean atLeastOneOr = parserProductions.stream().anyMatch(p -> p.result() instanceof Or);

		final IndentedStringBuilder sb = new IndentedStringBuilder(indent);
		sb.append("/*\n")
				.append(" * This file has been generated by the parser generator. Do not edit.\n")
				.append(" */\n");
		if (packageName != null && !packageName.isBlank()) {
			sb.append("package ").append(packageName).append(";\n\n");
		}
		if (generateMainMethod) {
			sb.append("import java.io.IOException;\n")
					.append("import java.nio.file.Files;\n")
					.append("import java.nio.file.Path;\n");
		}
		sb.append("import java.nio.ByteBuffer;\n")
				.append("import java.nio.ByteOrder;\n")
				.append("import java.util.ArrayList;\n")
				.append("import java.util.Arrays;\n")
				.append("import java.util.Base64;\n")
				.append("import java.util.List;\n");
		sb.append("import java.util.Objects;\n");
		if (atLeastOneSequence) {
			sb.append("import java.util.Stack;\n");
		}
		if (atLeastOneSequence || atLeastOneZeroOrMore || generateMainMethod) {
			sb.append('\n');
		}
		sb.append("public final class ")
				.append(parserName)
				.append(" {\n")
				.indent()
				.append("private Token[] v = null;\n")
				.append("private int pos = 0;\n");
		if (atLeastOneSequence) {
			sb.append("private final Stack<Integer> stack = new Stack<>();\n");
		}
		sb.append("public interface Node {\n")
				.indent()
				.append("String name();\n")
				.deindent()
				.append("}\n")
				.append("public record Terminal(String literal) implements Node {\n")
				.indent()
				.append("@Override\n")
				.append("public String name() {\n")
				.indent()
				.append("return \"Terminal\";\n")
				.deindent()
				.append("}\n")
				.deindent()
				.append("}\n")
				.append("public interface NonTerminal extends Node {\n")
				.indent()
				.append("Node match();\n")
				.deindent()
				.append("}\n");
		if (atLeastOneZeroOrOne) {
			sb.append("public interface ZeroOrOne extends Node {\n")
					.indent()
					.append("Node match();\n")
					.deindent()
					.append("}\n");
		}
		if (atLeastOneSequence) {
			sb.append("public interface Sequence extends Node {\n")
					.indent()
					.append("List<Node> nodes();\n")
					.deindent()
					.append("}\n");
		}
		if (atLeastOneZeroOrMore) {
			sb.append("public interface ZeroOrMore extends Node {\n")
					.indent()
					.append("List<Node> nodes();\n")
					.deindent()
					.append("}\n");
		}
		if (atLeastOneOneOrMore) {
			sb.append("public interface OneOrMore extends Node {\n")
					.indent()
					.append("List<Node> nodes();\n")
					.deindent()
					.append("}\n");
		}
		if (atLeastOneOr) {
			sb.append("public interface Or extends Node {\n")
					.indent()
					.append("Node match();\n")
					.deindent()
					.append("}\n");
		}

		final ParserSerializer ps = new ParserSerializer(sb, tokenNames, NODE_NAMES);
		ps.generateParser(parserProductions);

		final String lexerName = parserName + "_Lexer";
		DFASerializer.generateLexer(sb, lexerName, lexerProductions);

		sb.append("public Node parse(final String input) {\n")
				.indent()
				.append("final Node result;\n")
				.append("final " + lexerName + " lexer = new " + lexerName + "();\n")
				.append("try {\n")
				.indent()
				.append("this.v = lexer.tokenize(input).toArray(new Token[0]);\n")
				.deindent()
				.append("} catch (final IllegalArgumentException e) {\n")
				.indent()
				.append("return null;\n")
				.deindent()
				.append("}\n")
				.append("this.pos = 0;\n")
				.append("try {\n")
				.indent()
				.append("result = parse_" + startSymbol + "();\n")
				.deindent()
				.append("} catch (final ArrayIndexOutOfBoundsException e) {\n")
				.indent()
				.append("return null;\n")
				.deindent()
				.append("}\n");
		if (atLeastOneSequence) {
			sb.append("return (pos == v.length && stack.isEmpty()) ? result : null;\n");
		} else {
			sb.append("return pos == v.length ? result : null;\n");
		}
		sb.deindent().append("}\n");

		if (generateMainMethod) {
			sb.append(
							"private static void printNode(final Node n, final String indent, final String continuationIndent) {\n")
					.indent()
					.append("final char verticalLine = '│';\n")
					.append("final char horizontalLine = '─';\n")
					.append("final char joint = '├';\n")
					.append("final char angle = '└';\n")
					.append("switch (n) {\n")
					.indent()
					.append("case Terminal t -> System.out.println(indent + \"Terminal '\" + t.literal() + \"'\");\n")
					.append("case NonTerminal nt -> {\n")
					.indent()
					.append("System.out.println(indent + nt.name());\n")
					.append(
							"printNode(nt.match(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
					.deindent()
					.append("}\n");
			if (atLeastOneOr) {
				sb.append("case Or or -> {\n")
						.indent()
						.append("System.out.println(indent + or.name());\n")
						.append(
								"printNode(or.match(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			if (atLeastOneSequence) {
				sb.append("case Sequence s -> {\n")
						.indent()
						.append("System.out.println(indent + s.name());\n")
						.append("final List<Node> children = s.nodes();\n")
						.append("final int len = children.size();\n")
						.append("for (int i = 0; i < len - 1; i++) {\n")
						.indent()
						.append(
								"printNode(children.get(i), continuationIndent + \" \" + joint + horizontalLine, continuationIndent + ' ' + verticalLine + ' ');\n")
						.deindent()
						.append("}\n")
						.append(
								"printNode(children.getLast(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			if (atLeastOneZeroOrMore) {
				sb.append("case ZeroOrMore zom -> {\n")
						.indent()
						.append("System.out.println(indent + zom.name());\n")
						.append("final List<Node> children = zom.nodes();\n")
						.append("final int len = children.size();\n")
						.append("for (int i = 0; i < len - 1; i++) {\n")
						.indent()
						.append(
								"printNode(children.get(i), continuationIndent + \" \" + joint + horizontalLine, continuationIndent + ' ' + verticalLine + ' ');\n")
						.deindent()
						.append("}\n")
						.append(
								"printNode(len == 0 ? null : children.getLast(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			if (atLeastOneOneOrMore) {
				sb.append("case OneOrMore oom -> {\n")
						.indent()
						.append("System.out.println(indent + oom.name());\n")
						.append("final List<Node> children = oom.nodes();\n")
						.append("final int len = children.size();\n")
						.append("for (int i = 0; i < len - 1; i++) {\n")
						.indent()
						.append(
								"printNode(children.get(i), continuationIndent + \" \" + joint + horizontalLine, continuationIndent + ' ' + verticalLine + ' ');\n")
						.deindent()
						.append("}\n")
						.append(
								"printNode(children.getLast(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			if (atLeastOneZeroOrOne) {
				sb.append("case ZeroOrOne zoo -> {\n")
						.indent()
						.append("System.out.println(indent + zoo.name());\n")
						.append(
								"printNode(zoo.match(), continuationIndent + \" \" + angle + horizontalLine, continuationIndent + \"   \");\n")
						.deindent()
						.append("}\n");
			}
			sb.append("case null -> System.out.println(indent + \"null\");\n")
					.append(
							"default -> throw new IllegalArgumentException(String.format(\"Unknown node: '%s'.\", n));\n")
					.deindent()
					.append("}\n")
					.deindent()
					.append("}\n")
					.append("public static void main(final String[] args) {\n")
					.indent()
					.append("if (args.length != 1) {\n")
					.indent()
					.append("throw new RuntimeException(\"Expected the file to read input from.\");\n")
					.deindent()
					.append("}\n")
					.append("final ")
					.append(parserName)
					.append(" parser = new ")
					.append(parserName)
					.append("();\n")
					.append("final Node result;\n")
					.append("try {\n")
					.indent()
					.append("result = parser.parse(Files.readString(Path.of(args[0])));\n")
					.deindent()
					.append("} catch (final IOException e) {\n")
					.indent()
					.append("throw new RuntimeException(e);\n")
					.deindent()
					.append("}\n")
					.append("printNode(result, \"\", \"\");\n")
					.deindent()
					.append("}\n");
		}

		return sb.deindent().append("}").toString();
	}

	private static void generateNames(final List<Production> parserProductions) {
		final Set<Node> visited = new HashSet<>();
		final Queue<Node> q = new ArrayDeque<>();

		for (final Production p : parserProductions) {
			q.add(p.start());
			q.add(p.result());
			NODE_NAMES.put(p.result(), p.start().name());
		}

		int zeroOrOneCounter = 0;
		int sequenceCounter = 0;
		int zeroOrMoreCounter = 0;
		int oneOrMoreCounter = 0;
		int orCounter = 0;
		while (!q.isEmpty()) {
			final Node n = q.remove();
			if (visited.contains(n)) {
				continue;
			}
			visited.add(n);
			switch (n) {
				case Terminal ignored -> {}
				case NonTerminal nt -> NODE_NAMES.put(nt, nt.name());
				case ZeroOrOne zoo -> {
					NODE_NAMES.put(zoo, "zero_or_one_" + zeroOrOneCounter);
					q.add(zoo.inner());
					zeroOrOneCounter++;
				}
				case ZeroOrMore zom -> {
					NODE_NAMES.put(zom, "zero_or_more_" + zeroOrMoreCounter);
					zeroOrMoreCounter++;
					q.add(zom.inner());
				}
				case OneOrMore oom -> {
					NODE_NAMES.put(oom, "one_or_more_" + oneOrMoreCounter);
					oneOrMoreCounter++;
					q.add(oom.inner());
				}
				case Sequence s -> {
					NODE_NAMES.put(s, "sequence_" + sequenceCounter);
					sequenceCounter++;
					q.addAll(s.nodes());
				}
				case Or or -> {
					NODE_NAMES.put(or, "or_" + orCounter);
					orCounter++;
					q.addAll(or.nodes());
				}
				default -> throw new IllegalArgumentException(String.format("Unknown Node '%s'.", n));
			}
		}
	}
}
